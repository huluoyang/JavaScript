2007 年的大部分时间，ES4 的工作组都认为 ES3.1 规范的作用仅仅只是与 ES4 进行竞争的一个简单的尝试，并且没有任何的技术含量。然而，Douglas Crockford, Pratap Lakshman, 以及 Allen Wirfs-Brock 却认为发展 ES3 规范的升级版，将会使它更新，并能够解决许多根本的交互问题。发布初始目标之后的第一步，设计 ES3.1 的核心概念，并对其在功能级上的改进 [Lakshman et al. 2007] 都旨在（让开发者）了解浏览器中 JavaScript 的现状以及 Web 实现与 ES3 规范的不同之处。

ES3.1 工作组即时关注的一个点在于，微软为 IE 实现的 JScript 是一个不复杂的 Web 标准。为了去了解 ECMAScript 中关于“有效性”、“作用域”等概念，Allen Wirfs-Brock 请求 Pratap Lakshman 做了一个分析，来找出 IE JScript 中与 ES3 相背离的地方。这篇 87 页之长的报告 “JScript Deviations from ES3”[Lakshman 2007c] 最终于 2007 年的 9 月份完成。这篇报告主要阐述了三个部分。第一部分主要指明了各个地方的现用 JScript 实现与 ES3 规范中的明确要求相背离的地方。

![image](https://user-images.githubusercontent.com/17036920/76719486-e1c6f080-6774-11ea-90a7-1b01694f3b00.png)

对于每一个相背离的地方，这篇报告都提供了其违反了 ES3 规范语言的地方、并设置了一个测试用例来观察这些地方、以及在当时的四大主流浏览器 Internet Explorer, Mozilla Firefox, Opera 和 Apple Safari 的实际现用标准上运行这些测试的结果。图 29 就展示了其中的一个例子。有些相背离的地方是在 IE 中独一无二的，有些则表现在所有的浏览器中，还有一些表现在 IE 与其他一到两个的浏览器之中。

这篇报告的第二段指出了 ES3 规范中哪些行为是被明确的定义，并在实现中被依赖，哪些又是没有被明确定义的所有地方。这一段同样提供了测试用例，以及在主流浏览器上运行测试的结果。报告的最一段描述了在 IE 浏览器上对于 ES3 规范的扩展实现。Wirfs-Brock[2007b] 同样准备了一份清单来描述 Firefox 对于 ES3 的扩展。Douglas Crockford 和 Allen Wirfs-Brock 于 2007 年 8 月 16 日会面，并且评审了这些文档的草案。这些会面的结果造成了一些在 ES3.1 规范中的关键改变。[Wirfs-Brock and Crockford 2007]

在 ES3.1 的开发过程中，于 2008 年 1 月份的 TC39 大会上进行了一次正式的线下会议，主要目标是进行评审，部分 TC39 的成员对这项工作表示了兴趣。在 2 月 11 日，Lakshman 向 TC39 的私人邮箱发送了一份 ES3.1 的号召性用语。这封邮件提醒注意去年夏天准备的关于背离性与与互用性的文档，并希望得到更多的反馈。在 2 月 21 日，召开了一次电话会议，并确定了之后每两周一次电话会议的工作计划。与之前参与讨论 ES3.1 的人数相比，这些电话会议的参与人数更多。图 30 列出了这些参与者。一开始，人们直接发送邮件来交换或者讨论观点。一些关于 ES3.1 的讨论也被加到了关于讨论 ES4 的邮件论坛中。然而，由于与 ES4 相关的主题的数量，使得很难从其中找出关于 ES3.1 规范的主题，所以在 4 月份，一个关于讨论 ES3.1 的邮件分论坛[TC39 et al. 2008] 成立了，绝大多数关于 ES3.1 设计的讨论都移到了这里。

![image](https://user-images.githubusercontent.com/17036920/76722110-3a9a8700-677d-11ea-96c7-201df958c9bc.png)

讨论的第一个议题 [TC39 2008d] 是评审 ES3.1 的总体目标以及在制定过程中，解决问题或添加功能应当遵守的设计规则。一个早期由 Microsoft Live 小组的开发者以及一些其他 Web 框架的开发者所倡导的观点是，应当避免任何语法上的扩展，因为这样可能会导致脚本在现存的旧版本浏览器中解析失败。但是，这个“不要有新语法”的规则过于局限，并且忽略了实际上各个浏览器已经有了某些语法扩展。这个讨论基于 Microsoft’s JScript Deviations 文档上分析出的四大浏览器（Internet Explorer, Firefox, Opera, and Safari）推导出了 “四分之三” 规则。当这些浏览器的四分之三都有某个功能或者一些通用行为的约定，那么这个约定就应当被应用到 ES3.1 的规范当中。这个规则明确了 ES3.1 该如何解决浏览器之间的互用性问题的讨论边界。

ES3.1 的总体概念上有一个约定，那就是不应当通过指定语言的的改变，从而改变现有主流浏览器之间互用的 Web 页面，而“对 Web 造成破坏”。但是已经存在了数以百万计的 Web 页面。它们实际上依赖了 ESMAScript 的哪些方面？又有哪些改变会造成 Web 破坏呢？ 浏览器的实现者的报告表明，因为大量现存网页的基础，任何互用的浏览器功能（不管是多模糊或者难以理解的用法）都有可能在现有的页面中有所应用。基于这个观点，四大浏览器通用的功能就不能再去更改了，而四分之三以上浏览器通用的功能则应当强烈被推荐称为标准。但是对于四分之二浏览器的通用行为，或者干脆这些行为与其他浏览器都不一样的行为该怎么办呢？显然，这些功能与行为在现存的页面的互用性上不是核心的，并且是可以通过规范的进程来修订的。

工作组同样注意到，通常情况下所有 ECMAScript 规范关于实现可变性的限制都不利于创建有互用性的 Web 页面。为了给语言实现者提供可变性，或者容纳在不同实现中已知的不同，传统语言规范可能会允许特定的实现变体的情况，这与通过各个独立浏览器来访问世界上的共用页面的想法是根本不兼容的。ECMAScript 规范比起传统语言规范，需要更多规定与细节，并且在任何可能的情况下，存在的差异实现限制都应该被消除。按照最早于 2 月份的讨论，Douglas Crockford [2008a] 发布了 ES3.1 目标的修订版至 TC39 的 Wiki。（图 31）

在 2008 年 3 月份的线下会议，工作组同意应当立即开始撰写 ES3.1 规范的实际文档。Patrap Lakshman 带着他从 Mozilla 维护的 ES3 勘误表进行过更正的 ES3 规范来到了会场 [Horwat 2003b]。工作组同意使用它作为 ES3.1 的基础文档，并请求 Lakshman 作为编辑者。和之前的版本一样，这篇规范文档应当又 Microsoft Word 来组成。相对于第三板的更改追踪，将会追踪规范的演进，以便于评审工作，并能确保这些改变可以与 ES4 整合在一起。工作组的成员被分配（图 32）为特定的新功能来开发规范文本。在他们完成以后，Lakshman 将会将它们的工作整合到主干草案之中。

![image](https://user-images.githubusercontent.com/17036920/76867551-a0336400-68a0-11ea-90fa-33af2ea2e9d8.png)

在 2008 年 5 月 29 日，Pratap Lakshman 向 TC39 wiki 发送了 ES3.1 规范的最初草案。更新的草案通常每周发布一次，而“评审草案”则一般每次 TC39 常例会议的前两到三周发布。在 2008 年 5 月 29 日到 2009 年 3 月 2 日之间，一共发布了 26 份中间草案。

长期以来，IBM 都主张 JavaScript 应当支持十进制运算。从 1998 年 11 月 19 日的 TC39 工作组会议开始，Mike Cowlishaw 都主张将其包含在 ES3 和 ES4 之中。当 IBM 重新参与到 TC39 之中 ES4 与 ES3.1 的修订时，他们再次强烈建议将对十进制运算的支持加入到标准之中。IBM 的参与者确保 TC39 意识到，在 IBM 的策略中反对任何没有包含支持十进制运算的新语言标准。许多 TC39 的成员都对这个目标的可行性表示了怀疑，但是 Brendan Eich 却支持 IBM， 并指出从 Firefox 的报告看来，许多常见的 bus 来自于 JavaScript 的开发者们并没有理解二进制浮点运算的语义。Eich 帮助 Sam Ruby 开始用 Mozilla 的 SpiderMonkey 引擎来开发一个原型，实现了将 IEEE-754-2008 十进制浮点数做为一个新的原始数据类型，并且可以与混合表达式中的 Number 类型结合使用。这个十进制功能的完整规范被纳入了 2008 年 9 月与 2008 年 11 月的 ES3.1 草案之中。在 2008 年 11 月 19 日至 20 日，TC39 会议举行了最后一次讨论，以决定哪些功能应当在 ES3.1 的草案中保留或移出。首先一个被考虑的就是十进制算术的支持。委员会的结论是十进制的设计依然非常不成熟，并且存在许多遗留的设计问题，这些问题在不延迟 ES3.1 发布的情况下是难以解决的。会议纪要记录了这些担忧，并给出了结论：

> 因为存在的这些担忧，决定将对包含十进制的支持推迟到 Harmony 修订版的 ECMAScript 之中。参与者承认，ECMAScript 的十进制提案去的了非常显著的进步，并且非常感谢 IBM 的 Sam Ruby 在这项开发中做出的努力。参与者鼓励 Sam 和其他 TC39 成员继续开发这项提案，并且十分乐观的认为十进制运算的完整、通用版本将会被集成到 Harmony 修订版之中。

而在 2009 年 1 月份发布的下一版审核草案中并没有十进制的特性。

在 2009 年 3 月 25 日-26 日的会议上 [TC39 2009d]，Pratap Lakshman 宣布他将辞去 ECMA-262 编撰者的职位，原因是微软将开发 JavaScript 的职责转译到了新的 Redmond-based 小组，并且他个人拒绝了这个迁移到这个小组的机会。委员会宣布 Allen Wirfs-Brock 接任他编撰者的工作。

Wrifs-Brock 回忆说，在一次 TC39 会议的休息时间里，他接触到了 Brendan Eich，并且建议 ES3.1 应当重新命名为一个整数的版本。这个讨论是因为 ES3.1 的新设计已经逐渐成长为了一个 ECMA-262 的完整修订版，其重要程度与之前的三个版本相当。因为 ES4 的修订工作已经终止的消息已经公开，设计 ES3.1 将其作为第四个版本将会对社区的 JavaScript 开发者以及 Web 搜索引擎找造成困扰。与之相反，Wirfs-Brock 建议应当永久废弃 ECMA-262 的第四版本设计，并且发布 ES3.1 作为第五个版本。Eich 赞成这个观点，所以当会议继续的时候，他们向整个委员会提出了这个想法，并得到了接受。当更新在会议上通过之后，委员会接受了当前版本的草案作为最终草案。在 2009 年 4 月 7 日，这个最终草案作为第 5 版设计 [Lakshman et al. 2009] 发布了出来。在最终草案之后，还发布了 5 个候选草案，主要包含了一些小的技术或编辑方面的勘误。在 2009 年 8 月份，Apple 公司发现 [Hunt2009] 这个决议使得 `arguments` 这个对象是从 `Array` 对象的原型继承过来的，将会导致其与原型框架产生意外的交互，从而破坏一些 Apple 公司或 NASA 的网站。因此这个改变在最终的规范中被移除了。

在 2009 年 9 月 23 日，TC39 [2009b] 投票通过了 ES5 的完成，并将其转发给 Ecma General Assembly 申请通过。Ecma GA 在 2009 年 10 月 28 日评审并通过了这份最终草案。而 ECMA-262 的第五版则在 2009 年 11 月 3 日得到了 Ecma GA 的通过 [Ecma
International 2009a]，这距离上一次通过第 3 版本已经过去了十年之久。在 GA 的中，赞成票为 19 票，反对票为 2 票。其中 IBM 投了反对票，因为这个标准并没有包含对十进制运算的支持。Intel 说他们没有投票，并简单地表示是因为它们没有足够的时间对这个规范进行完整的知识产权评审。

ECMA-262 第五版是作为 ISO/IEC ECMAScript 标准的快速修订版而提交的。它经历了 ISO 国家机构的评审过程，根据其反馈，Allen Wirfs-Brock 在规范上整合了一些编辑上的勘误和澄清。这一修订版在 2011 年 6 月作为 ECMA-262 第 5.1 版与 ISO/IEC 26262 第三版而发布。

### 20.1 ES5 技术设计

尽管最初 ES3.1 的目标非常地保守，但 ES5 依然包含了一些技术革新。

_20.1.1 严格模式。_ ES5 的严格模式是 Douglas Crockford 旨在 JavaScript 设计中“纠正错误与不变”的直接最终产品。其中一些不便，诸如不能用保留字作为字面对象的属性键，并且在点之后的引用在当前都是一种语法错误，在 ES5 中都可以在不改变当前代码的情况下进行更正。然而许多 JavaScript 的不当行为都不能随意的修正，因为这种改变将有可能改变现有代码的运行时行为，并因此“破坏这个页面”。严格模式的想法，是为了给 JavaScript 开发者一个机会，通过显示的加入包含这些修复的“方言”来更新代码。浏览器应该必须要同时支持严格模式与非严格模式，并且在理想状况下，严格模式应该选择性地独立添加在函数层面，这样以保证已有的程序可以逐步地转变成严格模式。理想状况下，随着时间的退役，严格模式将会成为写新代码的主流“方言”。然而，最初的选择是更重要的问题。这意味着在所有浏览器中实施 ES5 的严格模式还有很长的路要走。浏览器游戏理论预测，如果在某些主流浏览器上严格模式使代码无法工作，那么开发人员就不会使用它。使用减法严格模式可以避免这个问题。它不往 ECMAScript 添加任何新特性；而是去除掉可能有问题的特性。当 Bug-free 的严格模式代码运行在并不支持严格模式的浏览器之上时，应当继续按照开发者的期望运行。

一个比较早的问题是该如何选择加入严格模式。细粒度地选择严格模式要求有一种机制让其可以轻松的嵌入到脚本之中。它不能是类似 `<script>` 元素的属性这种外部引入。在 ES4 的尝试中已经考虑过使用指令来让 ECMAScript 代码来选择不同的模式。但是新的指令会破坏 ES3.1 “不要添加新的语法”这一设计规则。一种可能性是使用特殊格式的注释来作为这些指令。然而，ES3.1 工作组并不愿意从语义上显式地添加任何格式的注释，因为 JavaScript 的最小化器会去除注释。Allen Wirfs-Brock 观察到 ECMAScript 的 _表达式语句_ 的语法可以创建任意表达式，包括那些只有一个字符的字符串常量，只需要在其后显式或者隐式（通过 ASI）地跟上分号，就可以使其成为一个有效的语句。这意味着类似 `"use strict";` 这样的语句在 ES3 的代码中是语法正确的。因为它是一个简单的常量值，所以评估其在 ES3 中不会有任何的副作用。它是一个 _no-op_ 。使用这样的语句来作为严格模式的选择是相对安全的，因为任何现有的 JavaScript 看起来都不太可能使用这一条特定格式的语句，并且在 ES3 中的实现将会自动忽略它在其他 ES5 代码中被带入的特性。工作组采纳了这个观点。`"use strict";` 这个格式的语句，如果被放置在一个脚本或者一个函数体的第一句，将表明整个脚本或者函数将会使用严格模式的语法来运行。

严格模式一个主要的目标是显式地抓取容易出现缺又在运行时不明显的编码错误。严格模式添加了如下新的运行时错误：

- 给未声明的标识符赋值。在旧版本的 JavaScript 中，对错误的变量名赋值将会导致在全局对象上创建一个属性。
- 给一个拥有只读属性或者继承的属性赋值。在旧版本的 JavaScript 中，这种行为将会静默地不做任何改变。
- 尝试在一个不可扩展的对象上创建一个属性。在 ES5 之前，不会存在这样的对象。但是为了与旧版本一致，在 ES5 的非严格模式的情况下，这种行为将会静默地不做任何改变。
- 对一个不可删除的属性使用 `delete` 操作符。在旧版本 JavaScript 中，`delete` 将会返回一个 `false`。
- 对变量引用使用 `delete` 操作符将会产生语法错误。在旧版本 JavaScript 中， `delete` 对于显示声明的变量将会返回 `false` 。而如果变量引用是通过对象的 `with` 语句支持的，或者是全局对象的属性，则它将在旧版本的 JavaScript 中删除。

严格模式还移出或者修改了一些可能使得程序更加混乱、难以优化、或者不安全的特性：

- `with` 语句将不被允许。`with` 语句会为变量提供一个动态的作用域，这将会导致混乱，并且难以实现优化。
- `eval` 函数将不能用于动态地绑定现有的作用域。
- 函数的 `arguments` 对象将不会与其形参结合(§3.7.5)。取而代之，严格模式下的 `aguments` 对象是一个类数组对象，它的元素是传入函数的参数值的快照。修改这些元素将不会修改对应形参的值，反之亦然。
- 在严格模式下函数的 `arguments` 对象将不会有 `callee` 属性(§5)。传递这样的对象给其他的 code 将不会再隐式地传递一个调用其对应函数的能力。
- 在严格模式下的函数将禁止在 `arguments` 对象上实现提供 `caller` 属性(§3.7.5) 。`caller` 属性在 ES3 中曾是一个不标准但是广泛实现的扩展，这个扩展使其拥有可以访问函数的调用堆栈或者检索调用函数的功能。
- 调用一个严格模式的函数，而不提供一个 `this` 值，将不会使全局对象在函数中可以被引用(§3.7.4)。

在 Douglas Crockford [2007d] 的错误与不便的清单中，还有些其他特性在严格模式中有被考虑，但是并没有被加入进去。对于这些特性，TC 39 对其是不受欢迎还是不可被删减的情况并没有达成共识。举个例子，Crockford 与其他一些成员不喜欢 JavaScript 的**自动分号补全**，但许多开发者更喜欢在编码过程中不显式地添加分号。还有，更改 `typeof null` 的含义，使其返回不为 `"object"` 的提议也没有被通过。

20.1.2 _Getters, Setters, Object Meta 操作符。_ 在 JavaScript 的最开始实现中，有些内置或者宿主对象会有些特殊的属性，这些属性在其他 JavsScript 代码中创建的对象中并不可用。举个例子，一些属性会有只读的值，或者不能用 `delete` 操作符将其删除，并且内置的属性方法或者宿主的对象将会在使用 `for-in` 语句枚举属性的时候被跳过。在 ES1 中，这些特殊的语义是通过添加诸如 ReadOnly, DontDelete 以及 DontEnum 这一类特殊的对象属性模式来指定的。这些属性由一些更加直观的语义化的伪代码来进行测试。这些属性并不规范——在 JavaScript 代码中没有任何的语言特性使得可以为现有或者新创建的属性中设置这些属性。ES3 中添加了一个 `Object.prototype.propertyIsEnumerable` 方法来测试 DontEnum 属性的存在，但是并没有相应的方法对 ReadOnly 和 DontDelete 属性来进行没有副作用的测试。同样的，许多浏览器 DOM 中提供的宿主对象暴露出的属性，被命名为 “getter/setter 属性”，但在 ES5 中被名为为了“访问者属性”，当设置或访问这些属性的时候会导致计算。对这些特性缺乏标准的支持，导致了 JavaScript 的开发者们无法去定义一个与内置或者宿主对象相同作用的库，或者说实现一个模拟这些对象的补丁库。

对于这些问题统一的解决标准是新版 ES5 的功能中最大的集合。这些特性并没有一个官方的名称，但是在非正式场合一般称为“静态对象函数”或者“对象反射函数”。Allen Wirfs-Brock [2008] 对这个特性集写了一部设计原理文档。它介绍遵循这些设计准则的用例：

- 干净地将元和应用层分开
- 试图最小化 API 的表面，例如减少方法的数量以及它们参数的复杂度。
- 专注于命名和参数设计的可用性
- 在一个设计中尝试复用基础元素
- 如果可能，使程序员或者实现者可以静态优化 API 的使用
